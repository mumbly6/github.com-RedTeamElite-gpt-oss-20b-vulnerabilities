# LLM Vulnerability Analysis Notebook
# This notebook analyzes the results from the vulnerability assessment

import json
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from datetime import datetime
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Set style for better visualizations
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

class VulnerabilityAnalyzer:
    def __init__(self, findings_dir="findings"):
        self.findings_dir = findings_dir
        self.data = self.load_all_findings()
    
    def load_all_findings(self):
        """Load all JSON findings files"""
        findings = {}
        try:
            # Load summary
            with open(f"{self.findings_dir}/01_assessment_summary.json", "r") as f:
                findings['summary'] = json.load(f)
            
            # Load specific vulnerability types
            vuln_types = ['prompt_injection', 'data_extraction', 'jailbreak']
            file_numbers = ['02', '03', '04']
            
            for i, vuln_type in enumerate(vuln_types):
                try:
                    with open(f"{self.findings_dir}/{file_numbers[i]}_{vuln_type}_findings.json", "r") as f:
                        findings[vuln_type] = json.load(f)
                except FileNotFoundError:
                    print(f"Warning: {vuln_type} findings file not found")
                    findings[vuln_type] = {"findings": []}
            
            # Load detailed results
            with open(f"{self.findings_dir}/05_detailed_results.json", "r") as f:
                findings['detailed'] = json.load(f)
                
        except Exception as e:
            print(f"Error loading findings: {e}")
            return {}
        
        return findings
    
    def create_summary_dashboard(self):
        """Create a comprehensive summary dashboard"""
        if not self.data:
            print("No data available for analysis")
            return
        
        # Create subplots
        fig = make_subplots(
            rows=2, cols=3,
            subplot_titles=(
                'Vulnerability Severity Distribution',
                'Vulnerabilities by Type',
                'Model Comparison',
                'Confidence Score Distribution',
                'Response Length Analysis',
                'Timeline Analysis'
            ),
            specs=[[{"type": "pie"}, {"type": "bar"}, {"type": "bar"}],
                   [{"type": "histogram"}, {"type": "box"}, {"type": "scatter"}]]
        )
        
        # 1. Severity Distribution
        severity_data = self.data['summary']['overall_summary']['severity_breakdown']
        fig.add_trace(
            go.Pie(
                labels=list(severity_data.keys()),
                values=list(severity_data.values()),
                name="Severity"
            ),
            row=1, col=1
        )
        
        # 2. Vulnerabilities by Type
        vuln_by_type = {}
        for vuln_type in ['prompt_injection', 'data_extraction', 'jailbreak']:
            if vuln_type in self.data:
                vuln_by_type[vuln_type] = len(self.data[vuln_type]['findings'])
        
        fig.add_trace(
            go.Bar(
                x=list(vuln_by_type.keys()),
                y=list(vuln_by_type.values()),
                name="Vulnerability Type"
            ),
            row=1, col=2
        )
        
        # 3. Model Comparison
        if 'detailed' in self.data:
            models = []
            vuln_counts = []
            for model_result in self.data['detailed']['full_test_results']['results']:
                models.append(model_result['model'])
                vuln_counts.append(model_result['summary']['vulnerabilities_found'])
            
            fig.add_trace(
                go.Bar(x=models, y=vuln_counts, name="Model Vulnerabilities"),
                row=1, col=3
            )
        
        # 4. Confidence Score Distribution
        confidence_scores = []
        if 'detailed' in self.data:
            for model_result in self.data['detailed']['full_test_results']['results']:
                for test in model_result['tests']:
                    if test['analysis']['vulnerable']:
                        confidence_scores.append(test['analysis']['confidence'])
        
        fig.add_trace(
            go.Histogram(x=confidence_scores, name="Confidence Scores"),
            row=2, col=1
        )
        
        # 5. Response Length Analysis
        response_lengths = []
        if 'detailed' in self.data:
            for model_result in self.data['detailed']['full_test_results']['results']:
                for test in model_result['tests']:
                    response_lengths.append(test['analysis']['response_length'])
        
        fig.add_trace(
            go.Box(y=response_lengths, name="Response Lengths"),
            row=2, col=2
        )
        
        # Update layout
        fig.update_layout(
            title_text="LLM Vulnerability Assessment Dashboard",
            showlegend=False,
            height=800
        )
        
        fig.show()
        return fig
    
    def analyze_vulnerability_patterns(self):
        """Analyze patterns in vulnerabilities"""
        if not self.data or 'detailed' not in self.data:
            print("Insufficient data for pattern analysis")
            return
        
        # Create DataFrame for analysis
        analysis_data = []
        for model_result in self.data['detailed']['full_test_results']['results']:
            for test in model_result['tests']:
                analysis_data.append({
                    'model': model_result['model'],
                    'test_type': test['test_type'],
                    'vulnerable': test['analysis']['vulnerable'],
                    'confidence': test['analysis']['confidence'],
                    'severity': test['analysis']['severity'],
                    'response_length': test['analysis']['response_length'],
                    'contains_refusal': test['analysis']['contains_refusal'],
                    'contains_harmful_content': test['analysis']['contains_harmful_content'],
                    'test_id': test['test_id']
                })
        
        df = pd.DataFrame(analysis_data)
        
        # Vulnerability rate by test type
        vuln_by_type = df.groupby('test_type')['vulnerable'].agg(['sum', 'count', 'mean']).round(3)
        vuln_by_type.columns = ['Vulnerabilities Found', 'Total Tests', 'Vulnerability Rate']
        
        print("Vulnerability Analysis by Test Type:")
        print("=" * 50)
        print(vuln_by_type)
        print("\n")
        
        # Model comparison
        vuln_by_model = df.groupby('model')['vulnerable'].agg(['sum', 'count', 'mean']).round(3)
        vuln_by_model.columns = ['Vulnerabilities Found', 'Total Tests', 'Vulnerability Rate']
        
        print("Vulnerability Analysis by Model:")
        print("=" * 40)
        print(vuln_by_model)
        print("\n")
        
        # Correlation analysis
        numeric_cols = ['confidence', 'response_length']
        correlation_data = df[df['vulnerable'] == True][numeric_cols]
        
        if not correlation_data.empty:
            print("Correlation Analysis (Vulnerable Cases Only):")
            print("=" * 45)
            print(correlation_data.corr())
        
        return df
    
    def create_detailed_visualizations(self):
        """Create detailed visualizations"""
        df = self.analyze_vulnerability_patterns()
        
        if df.empty:
            print("No data available for visualization")
            return
        
        # Create multiple visualizations
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        
        # 1. Vulnerability rate by test type
        vuln_by_type = df.groupby('test_type')['vulnerable'].mean()
        vuln_by_type.plot(kind='bar', ax=axes[0,0], title='Vulnerability Rate by Test Type')
        axes[0,0].set_ylabel('Vulnerability Rate')
        axes[0,0].tick_params(axis='x', rotation=45)
        
        # 2. Confidence score distribution
        vulnerable_df = df[df['vulnerable'] == True]
        if not vulnerable_df.empty:
            axes[0,1].hist(vulnerable_df['confidence'], bins=20, alpha=0.7)
            axes[0,1].set_title('Confidence Score Distribution (Vulnerable Cases)')
            axes[0,1].set_xlabel('Confidence Score')
            axes[0,1].set_ylabel('Frequency')
        
        # 3. Response length vs vulnerability
        sns.boxplot(data=df, x='vulnerable', y='response_length', ax=axes[1,0])
        axes[1,0].set_title('Response Length by Vulnerability Status')
        axes[1,0].set_xlabel('Vulnerable')
        axes[1,0].set_ylabel('Response Length')
        
        # 4. Vulnerability heatmap by model and test type
        heatmap_data = df.groupby(['model', 'test_type'])['vulnerable'].mean().unstack()
        sns.heatmap(heatmap_data, annot=True, cmap='Reds', ax=axes[1,1])
        axes[1,1].set_title('Vulnerability Rate Heatmap')
        
        plt.tight_layout()
        plt.show()
        
        return fig
    
    def generate_recommendations(self):
        """Generate security recommendations based on findings"""
        if not self.data:
            print("No data available for recommendations")
            return
        
        recommendations = {
            "critical_issues": [],
            "high_priority": [],
            "medium_priority": [],
            "general_recommendations": []
        }
        
        # Analyze critical issues
        total_critical = self.data['summary']['overall_summary']['severity_breakdown'].get('critical', 0)
        if total_critical > 0:
            recommendations["critical_issues"].append(
                f"Found {total_critical} critical vulnerabilities requiring immediate attention"
            )
        
        # Check for specific vulnerability types
        for vuln_type in ['prompt_injection', 'data_extraction', 'jailbreak']:
            if vuln_type in self.data:
                findings_count = len(self.data[vuln_type]['findings'])
                if findings_count > 0:
                    if vuln_type == 'jailbreak':
                        recommendations["critical_issues"].append(
                            f"Jailbreak vulnerabilities detected: Implement stronger safety filters"
                        )
                    elif vuln_type == 'prompt_injection':
                        recommendations["high_priority"].append(
                            f"Prompt injection vulnerabilities: Enhance input validation and sanitization"
                        )
                    elif vuln_type == 'data_extraction':
                        recommendations["medium_priority"].append(
                            f"Data extraction attempts: Review information disclosure policies"
                        )
        
        # General recommendations
        recommendations["general_recommendations"].extend([
            "Implement comprehensive input validation and filtering",
            "Deploy content safety classifiers before and after generation",
            "Regular security audits and red team exercises",
            "User education on responsible AI usage",
            "Monitoring and logging of suspicious interactions",
            "Rate limiting and abuse detection mechanisms"
        ])
        
        return recommendations
    
    def export_analysis_report(self, filename="vulnerability_analysis_report.html"):
        """Export comprehensive analysis report"""
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>LLM Vulnerability Analysis Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                h1, h2, h3 {{ color: #333; }}
                .summary {{ background-color: #f0f0f0; padding: 15px; border-radius: 5px; }}
                .critical {{ color: #d32f2f; }}
                .high {{ color: #f57c00; }}
                .medium {{ color: #fbc02d; }}
                .low {{ color: #388e3c; }}
                table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
            </style>
        </head>
        <body>
            <h1>LLM Vulnerability Analysis Report</h1>
            <p><strong>Generated:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            
            <div class="summary">
                <h2>Executive Summary</h2>
                <p>Total Vulnerabilities Found: <strong>{self.data['summary']['overall_summary'].get('total_vulnerabilities', 0)}</strong></p>
                <p>Models Tested: <strong>{self.data['summary']['overall_summary'].get('total_models', 0)}</strong></p>
            </div>
            
            <h2>Severity Breakdown</h2>
            <table>
                <tr><th>Severity</th><th>Count</th></tr>
        """
        
        for severity, count in self.data['summary']['overall_summary']['severity_breakdown'].items():
            html_content += f"<tr><td class='{severity}'>{severity.title()}</td><td>{count}</td></tr>"
        
        html_content += """
            </table>
            
            <h2>Recommendations</h2>
        """
        
        recommendations = self.generate_recommendations()
        for category, items in recommendations.items():
            if items:
                html_content += f"<h3>{category.replace('_', ' ').title()}</h3><ul>"
                for item in items:
                    html_content += f"<li>{item}</li>"
                html_content += "</ul>"
        
        html_content += """
            </body>
            </html>
        """
        
        with open(filename, 'w') as f:
            f.write(html_content)
        
        print(f"Analysis report exported to {filename}")

# Example usage in Jupyter notebook
def run_analysis():
    """Main function to run the complete analysis"""
    print("Loading LLM Vulnerability Analysis...")
    analyzer = VulnerabilityAnalyzer()
    
    if not analyzer.data:
        print("No data found. Please run the vulnerability assessment first.")
        return
    
    print("Creating summary dashboard...")
    dashboard = analyzer.create_summary_dashboard()
    
    print("Analyzing vulnerability patterns...")
    df = analyzer.analyze_vulnerability_patterns()
    
    print("Creating detailed visualizations...")
    viz = analyzer.create_detailed_visualizations()
    
    print("Generating recommendations...")
    recommendations = analyzer.generate_recommendations()
    
    print("\nSecurity Recommendations:")
    print("=" * 50)
    for category, items in recommendations.items():
        if items:
            print(f"\n{category.replace('_', ' ').title()}:")
            for item in items:
                print(f"  • {item}")
    
    print("\nExporting analysis report...")
    analyzer.export_analysis_report()
    
    return analyzer, df, recommendations

# Run this cell to execute the analysis
if __name__ == "__main__":
    analyzer, data, recs = run_analysis()
